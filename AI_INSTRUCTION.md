# AI 协助说明文档 (AI Instruction)

在本项目的设计与实现过程中，AI（大语言模型）作为“结对编程伙伴”深度参与了核心代码的编写与架构决策。本其旨在以客观的视角记录 AI 的贡献边界、被否决的建议以及关键的人工决策逻辑。

## 1. AI 提供关键帮助的领域

### 1.1 核心算法的精确实现 (Algorithmic Precision)
在设计重试机制时，我初步构想是使用简单的固定指数退避。AI 提示了分布式系统中“惊群效应”（Thundering Herd）的风险，并推荐了 **Decorrelated Jitter（去相关抖动）** 算法。
*   **贡献点**：AI 不仅解释了数学原理，还直接推荐了 Python 的 `tenacity` 库及其 `wait_exponential_jitter` 函数。这比我手动实现随机算法更加健壮且不易出错。

### 1.2 模板引擎选型 (Technical Selection)
针对不同供应商异构的 API Body 格式，我最初打算使用 Python 原生的 f-string。AI 指出 f-string 难以处理嵌套 JSON 的转义以及复杂的条件逻辑（例如：仅当金额大于 X 时才包含某字段）。
*   **贡献点**：AI 推荐引入 **Jinja2** 模板引擎。它证明了 Jinja2 在处理 JSON 结构时的灵活性，使得无需修改代码仅改配置即可适配新供应商。这一建议直接提升了系统的扩展性。

### 1.3 基础设施快速搭建 (Scaffolding)
AI 生成了高质量的 `docker-compose.yml` 和 FastAPI 基础骨架代码。
*   **贡献点**：包含 Redis 健康检查（Healthcheck）的 Docker 配置和标准化的 FastAPI 错误处理结构，节省了约 30-45 分钟的查文档与调试时间，使我能将精力集中在核心的 Worker 逻辑上。

## 2. 未采纳的 AI 建议 (Rejected Suggestions)

### 2.1 建议使用 Celery 作为任务队列
AI 强烈推荐 Celery，理由是其功能丰富、支持工作流编排且生态成熟。
*   **拒绝原因（复杂度控制）**：对于 4 小时的 MVP 项目，Celery 过于笨重。它涉及繁琐的配置（Serializer, Backend, Windows 支持问题）。相比之下，**Python RQ (Redis Queue)** 代码量极少，概念简单，完全满足 MVP 的“生产-消费”模型。工程决策的核心在于“合适”而非“最强”。

### 2.2 建议实现“事务性发件箱”模式 (Transactional Outbox)
AI 建议引入 PostgreSQL，先将任务写入数据库表，再异步入队，以确保 100% 消息不丢失。
*   **拒绝原因（投入产出比）**：引入关系型数据库和 ORM 层会显著增加部署复杂度和代码量。在 MVP 阶段，依赖 Redis 的持久化（RDB/AOF）在可靠性与开发速度之间取得了更好的平衡。极小概率的数据丢失可以通过日志审计弥补，无需过度设计。

### 2.3 建议自动重试死信队列 (Auto-Retry DLQ)
AI 建议编写脚本自动重试死信队列中的任务。
*   **拒绝原因（运维安全）**：死信（Dead Letter）通常意味着非预期的配置错误或数据非法。自动重试不仅无效，还可能导致大量报错日志甚至触发外部系统的封禁。正确的做法是保持死信状态，等待人工介入修复后再手动重放。

## 3. 关键的人工决策 (Key Human Decisions)

### 3.1 系统边界的界定
*   **决策**：明确将“同步等待外部响应”和“OAuth2 复杂授权流程”排除在 MVP 之外。
*   **原因**：通知网关的核心价值是**异步解耦**与**削峰填谷**。如果网关试图理解业务逻辑或处理复杂的同步交互，它将变成一个紧耦合的“上帝对象”（God Object）。保持网关对业务数据的“不透明性”（Agnostic）是架构解耦的关键。

### 3.2 投递语义的选择 (At-Least-Once)
*   **决策**：选择“至少一次”投递，而非“至多一次”。
*   **原因**：业务底线是“不丢单”。在网络不稳定的现实环境下，宁可重复发送（让下游通过幂等键去重），也不能直接丢弃任务。这是由业务价值决定的可靠性底线。

### 3.3 拥抱“单体依赖” (Simplification)
*   **决策**：将 Vendor 配置直接存储在代码/Redis 中，而不引入额外的 Config Service 或数据库。
*   **原因**：MVP 的首要目标是可交付性。减少一个组件（Database），就减少了一分部署失败的风险。Redis 足以同时承担 Queue Broker 和简单 Key-Value 存储的职责。

---
**总结**：AI 在算法细节和代码生成上表现出色，但在架构取舍（Trade-off）上往往倾向于“大而全”的标准方案。真正的工程智慧体现在根据项目约束（时间、资源、目标）对 AI 的建议进行批判性的裁剪与取舍。
